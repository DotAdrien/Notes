Determining the Template Engine
Different template engines have distinct syntaxes and features, making them vulnerable to SSTI in various ways. Here are some examples of vulnerable template syntaxes:

Jinja2/Twig

Jinja2 and Twig are similar in syntax and behavior, making them somewhat challenging to distinguish from each other just by payload responses. However, you can detect their presence by testing their expression-handling capabilities. For example, using the vulnerable VM, if you use the payload {{7*'7'}} in Twig, the output would be 49.

Output of the payload is 49

However, if you use the same payload in an application that uses Jinja2, the output would be 7777777

Output of the payload is 7777777

Jade/Pug

Pug, formerly known as Jade, uses a different syntax for handling expressions, which can be exploited to identify its usage. Pug/Jade evaluates JavaScript expressions within #{}. For example, using the payload #{7*7} would return 49.

Output of the payload is 49

Unlike Jinja2 or Twig, Pug/Jade directly allows JavaScript execution within its templates without the need for additional delimiters like {{ }}. For example:

Exploitation
Before crafting a payload, it's essential to confirm if the application really uses Smarty. For example, go to http://ssti.thm:8000/smarty/.

Inject a simple Smarty tag like {'Hello'|upper} to see if it will be processed. If the application returns "HELLO", it means that the template engine used by the application is Smarty.

HELLO output using the above payload

Once you confirm that the site is vulnerable to SSTI via Smarty, you can craft a payload that uses PHP functions that execute system commands. One of the most common functions that do this is the system() function. Using the payload {system("ls")} is a direct and effective payload if Smarty's security settings allow PHP function execution.



Exploitation
Before crafting a payload, it is important to confirm if the application indeed uses Pug. For example, go to http://ssti.thm:8001/jade/.

Inject a basic Pug syntax to test for template processing, such as #{7*7}. If the application outputs 49, it confirms that Pug is processing the template.

Output is 49 using the above payload

Since Pug allows JavaScript interpolation, we can then use the payload #{root.process.mainModule.require('child_process').spawnSync('ls').stdout}

The above payload uses Node.js's core modules to execute system commands. Below is the breakdown:

root.process accesses the global process object from Node.js within the Pug template.
mainModule.require('child_process') dynamically requires the child_process module, bypassing potential restrictions that might prevent its regular inclusion.
spawnSync('ls'): Executes the ls command synchronously.
.stdout: Captures the standard output of the command, which includes the directory listing.

Correct Usage of spawnSync
To correctly use spawnSync to execute the ls command with -lah argument, you should separate the command and its arguments into two distinct parts:

const { spawnSync } = require('child_process');
const result = spawnSync('ls', ['-lah']);
console.log(result.stdout.toString());
In this corrected form:

'ls' is the command.
['-lah'] is an array containing all arguments passed to the command.
This structure ensures that the ls command is called with -lah as its argument, allowing the command to function as intended. So, the final payload will then be #{root.process.mainModule.require('child_process').spawnSync('ls', ['-lah']).stdout}

Exploitation
Before crafting a payload, it's crucial to confirm that the application indeed uses Jinja2. For example, go to http://ssti.thm:8002/jinja2/.

Inject a basic Jinja2 syntax like {{7*7}} to check for template processing. If the application returns 49, it indicates that Jinja2 is processing the template.

Output is 49 using the above payload

Once Jinja2's use is confirmed, we can the use the payload {{"".__class__.__mro__[1].__subclasses__()[157].__repr__.__globals__.get("__builtins__").get("__import__")("subprocess").check_output("ls")}}

Below is the breakdown of the above payload:

"".__class__.__mro__[1] accesses the base object class, the superclass of all Python classes.
__subclasses__(): Lists all subclasses of object, and [157] is typically the index for the subprocess.Popen class (this index may vary and should be checked in the target environment).
Classes dump using the above payload
second part of the screenshot above
The subsequent method chains dynamically import and use the subprocess module to execute the ls command, capturing its output.


https://github.com/vladko312/SSTImap


